Алгоритм перестроения графа классов.
1. Специальной программе gccxml подаются файлы с C++-кодом, в результате её работы формируется
    xml-файл, содержащий информацию об этом коде: классы (дана информация о названии, предках,
    абстрактности, методах и полях определенных в классе и пр.), методы (дана информация о названии,
    перегруженности, абстрактности, поступающих переменных и их типах, возвращаемом типе и пр.), типы и пр.

2. С помощью библиотеки "untangle" формируется объект класса "untangle.Element", хранящий ту же информацию,
    что и в xml-файле, но с ним уже можно работать как с python-объектом

3. Ввиду того, что получившийся объект хранит много лишней информации и не хранит некоторых нужных
    сведений, на основании python-объекта формируются две структуры: граф классов (представлен как
    ассоциативный массив, где ключ - id класса, а значение - ещё один ассоциативный массив, хранящий
    информацию об имени, потомках, предках, полях и методах, абстрактности класса и файле, в котором класс
    был объявлен), и список методов (представлен как ассоциативный массив, где ключ - id класса, а значение -
    ещё один ассоциативный массив, хранящий информацию об имени, возвращаемом типе, виртуальности (является
    ли метод виртуальным), перегрузке (является ли метод перегрузкой какого-то метода из класса-предка),
    доступе (метод указан как protected, public или private), номере строк, где метод начинается и
    заканчивается, количестве строк в методе и файле, в котором метод был объявлен)

4. В графе классов всё ещё недостаточно информации для того, чтобы приступить к выполнению основного
    алгоритма: xml-файл, возникающий в результате работы gccxml, не содержит информации о методах и полях,
    которые были унаследованы от предка и не были переопределены, поэтому и получившийся граф
    классов этой информации не содержит, а она потребуется, так как в дальнейшем будет необходимо оставить
    только одного предка для каждого класса, а остальные связи оборвать, то, если информацию не скопировать,
    она просто пропадет, что ведет к риску получить нерабочий код. Поскольку классы-предки сами могут иметь
    предков (а, значит, часть методов и полей может придти в класс-потомок из более далекого прапредка),
    нам нужно идти последовательно от корней (классов, не имеющих предков) и переносить все методы и поля из
    класса в класс, переименовывая методы и поля, пришедшие из разных классов, но имеющих одинаковое название.
    Для подобной операции обхода графа существуют 2 алгоритма - поиск в ширину и поиск в глубину, нам подходят
    оба. Я выбрал поиск в ширину, поскольку этот алгоритм обходит все вершины графа на одном уровне прежде,
    чем перейдет к другому (пусть корни - 0 уровень, тогда их потомки - 1 уровень, потомки этих потомков -
    2 уровень и т.д.). В случае возникновении конфликта имен при переносе следует переименовать метод/поле
    который вызвал неоднозначность путем добавления префикса. Роль префикса играет имя класса, откуда он был
    перенесен.
    - Поиском в ширину пройтись по графу, начиная с корней (их роль играют классы без предков) и на каждом шаге:
        1) Добавить к списку методов текущего узла все методы которые будут унаследованы и не будут
            переопределены, из всех его предков
            1.1) Если при добавлении возникает конфликт имен, то переименовать метод/поле добавив префикс -
                имя класса, откуда метод/поле был перенесен

5. Теперь можно приступать к основной части алгоритма. В ходе работы нам потребуются две вспомогательные функции:
        1) number_of_code_lines_in_inherited_methods: принимает два аргумента - id базового класса и id его потомка
            выдает суммарное количество строчек кода, которое придется перенести при переносе всех методов класса
        2) get_key_with_max_val: принимает один аргумент - ассоциативный массив, выдает - ключ, которому соответствует
            максимальное значение в данном ассоциативном массиве
    Обе функции нужны для того, чтобы выбрать единственный класс в качестве предка. В ходе работы алгоритма
    значительную часть кода приходится дублировать, поэтому в данном случае лучшим кандидатом считается класс из которого
    в результате наследования будет переносено наибольшее число строк кода. На предыдущем этапе мы добавили в классы
    все методы, которые были унаследованы и не были переопределены. После выбора класса-предка нам нужно убрать из
    текущего класса все методы, которые при наследовании там появятся, но оставить те, которые, ввиду обрыва связей,
    туда не попадут. Однако, если удалять методы из классов в произвольном порядке, то есть риск на определенном этапе
    не убрать лишнего, поскольку методы могли быть перенесены из более ранних классов-предков. Поэтому нам вновь нужно
    двигаться последовательно, но на этот раз от листьев (классов без потомков) и на каждом шаге рвать все цепочки, кроме
    одной, оставлять методы, которые мы рискуем потерять и убирать методы, которые есть в выбранном предке. Также
    необходимо убрать из предков текущего класса упоминание о нем. Как и ранее будем двигаться "по уровням", используя
    поиск в ширину.
    - Поиском в ширину пройтись по графу, начиная с листьев (их роль играют классы без потомков); каждом шаге:
        1) Сформировать список классов-предков текущего узла
        2) Добавить этот список на просмотр в будущем
        3) На основании списка сформировать словарь с ключом - id класса и
            значением - суммарным количеством строк кода во всех методах данного класса
        4) Выбрать в качестве предка класс, имеющий максимальное значение в созданном словаре
        5) Удалить из списка методов текущего узла все методы,
            присутствующие в выбранном предке, которые не переопределяются
        6) Удалить из списка базовых классов текущего узла всё, кроме выбранного предка
        7) Во всех базовых классах, кроме выбранного предка, удалить из списка потомков текущий узел